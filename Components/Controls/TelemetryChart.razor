@using Plotly.Blazor
@using Plotly.Blazor.LayoutLib
@using Plotly.Blazor.Traces.ScatterLib
@using System.Linq
@using System.Diagnostics
@using NegDelta.Services.Runtime.Interfaces

@inject ISimService iRacingService

<PlotlyChart @bind-Layout="layout"
@bind-Config="config" 
@bind-Data="data" 
@ref="chart" />

<MudText>Current count: @currentCount</MudText>

@code {
    private int currentCount = 0;
    private PlotlyChart chart;
    private Layout layout;
    private Config config;

    private List<TelemetryPoint> telemetryPoints = new();
    private IList<ITrace> data = new List<ITrace>();

    protected override void OnInitialized()
    {
        config = new Config();
        layout = new Layout
            {
                Title = new Title
                {
                    Text = "Telemetry Chart"
                }
            };

        data = new List<ITrace>
        {
            new Scatter
            {
                Name = "Throttle",
                Mode = ModeFlag.Lines,
                X = new List<object>(),
                Y = new List<object>(),
                Line = new Line
                {
                    Color = "green",
                    Shape = Plotly.Blazor.Traces.ScatterLib.LineLib.ShapeEnum.Spline,
                    Smoothing = (decimal)1
                }
            }
        };

        iRacingService.StartTelemetry();

        iRacingService.OnTelemetryUpdated += OnTelemetryReceived;
    }

    private void OnTelemetryReceived(object? sender, TelemetryPoint telemetryPoint)
    {
        _ = InvokeAsync(async () =>
        {
            if (chart.Data.FirstOrDefault() is not Scatter scatter)
            {
                Debug.WriteLine("No scatter trace found.");
                return;
            }
            Debug.WriteLine($"Telemetry received: {telemetryPoint.ThrottlePosition}");

            telemetryPoints.Add(telemetryPoint);
            currentCount++;

            // Tell blazor that the state has changed and it needs to re-render
            StateHasChanged();

            if (!scatter.X.Any() || !scatter.Y.Any())
            {
                scatter.X = new List<object>();
                scatter.Y = new List<object>();
            }

            // Update the chart data
            await chart.ExtendTrace((object)telemetryPoint.Timestamp.ToString("o"), (object)telemetryPoint.ThrottlePosition, data.IndexOf(scatter));
        });
    }

}
